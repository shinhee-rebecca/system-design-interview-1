# 7장 분산 시스템을 위한 유일 ID 생성기 설계

## 개요
분산환경이 아닐 경우 auto_increment속성이 설정된 관계형 데이터베이스의 기본 키를 쓰면 되지만, 분산 환경에서는 이 접근법이 통하지 않는다. 데이터베이스 서버 한 대로는 그 요구를 감당할 수 없고, 지연을 낮추기 매우 힘들다.

### ID 요구사항
- ID는 유일해야 한다.
- ID는 숫자로만 구성되어야 한다.
- ID는 64비트로 표현될 수 있는 값이어야 한다.
- ID는 발급 날짜에 따라 정렬 가능해야 한다.
- 초당 10,000개의 ID를 만들 수 있어야 한다.

---

## 다중 마스터 복제
<img width="931" height="620" alt="image" src="https://github.com/user-attachments/assets/fff4079e-ca76-4b64-8c4c-7e21bf179730" />


데이터베이스의 auto_increment기능을 활용하여 다음 ID를 구할 때 1이 아닌 데이터베이스 서버의 수 만큼 증가시켜 만드는 방법을 의미한다. 

### 장점
- 규모 확장성 문제를 어느정도 해결할 수 있다.
- 데이터베이스 수를 늘리면 초당 생산 가능 ID 수도 늘릴 수 있다.

### 단점
- 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다.
- ID의 유일성은 보장되겠지만, 그 값이 시간 흐름에 맞추어 커지도록 보장할 수는 없다.
- 서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어렵다.


---


## UUID
<img width="853" height="387" alt="image" src="https://github.com/user-attachments/assets/0fc0cdf4-d60d-4cbf-86fe-affabbd87715" />



컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트짜리 수다. UUID 값은 충돌 가능성이 낮다.

UUID 예시 : 6e3c18b5-405b-4931-bdbd-42f62f33ceea

### 장점
- UUID를 만드는 것은 단순하며, 서버 사이의 조율이 필요 없어 동기화 이슈가 없다.
- 각 서버가 직접 ID를 알아서 만드는 구조이므로 규모 확장도 쉽다.

### 단점
- ID가 128비트로 길다. 이번 문제의 요구사항은 64비트다.
- ID를 시간은으로 정렬할 수 없다.
- ID에 숫자 아닌 값이 포함될 수 있다.

<details>
<summary><strong>주요 UUID 종류(v4, v7)</strong></summary>

- **uuid v4**
  - 완전 램덤 혹은 의사 랜덤 생성을 통해 생성하는 ID이다.
  - 가장 널리 사용되고 2^122개의 값을 갖는다.
  - 예측이 불가능하며, 정렬되지 않는 키가 생성된다.
  - 구현이 간단하다.

- **uuid v7**
  - 48비트 Unix 타임스탬프 + 74 비트 랜덤 비트로 구성한다.
  - 시간순으로 자동정렬되어 데이터베이스 성능에 최적화 되어 있다.
  - id만으로 생성시간을 알 수 있다. ( 보안상 취약하다고 보는 견해도 있으나, 이번 장과는 크게 상관 없으므로 스킵 )
</details>


---


## 티켓서버
<img width="1061" height="538" alt="image" src="https://github.com/user-attachments/assets/380df3a4-f324-4252-a414-47caf69aea1f" />


auto_increment기능을 갖춘 데이터베이스 서버, 즉 티켓 서버를 중앙 집중형으로 하나만 사용하는 것을 의미한다.

### 장점
- 유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있다.
- 구현하기 쉽고, 중소 규모 애플리케이션에 적합하다.
### 단점
- 티켓 서버가 SPOF가 된다.
- 티켓 서버를 여러 대 준비하여 이를 피하게 되면 데이터 동기화 문제가 발생한다.
- 티켓 서버의 성능에 영향을 받는다.

---



## 트위터 스노우플레이크 접근법

트위터의 스노우 플레이크 id는 id요구사항을 모두 만족시킨다.

<img width="1100" height="166" alt="image" src="https://github.com/user-attachments/assets/efd4ced1-ce02-48c5-84b6-9ac4dc7605a5" />


|구분|비트수|내용|
|------|---|---|
|사인 비트|1|지금으로서는 쓰임새가 없고, 음수/양수 비교시에 사용가능하다.|
|타임스탬프|41|epoch 이후 몇 밀리초 경과했는지 나타내는 값이다. 69년간 사용가능하며 이 시간이 지나면 ID체계를 바꾸거나 다른것으로 이전해야 한다.|
|데이터 센터 ID|5|데이터센터를 의미한다.|
|서버 id|5|데이터센터당 사용할 수 있는 서버수를 나타낸다.|
|일련번호|12|각 서버에서는 ID를 생성할 때마다 이 일련번호를 1만큼 증가시킨다. 1밀리초 경과할 때마다 0으로 초기화한다.|

### 추가적으로 고려해야 하는 상황
- 시계 동기화가 필요하다. timestamp를 이요한 키값을 이용하기 위해서는 모든 인스턴스에서 전부 같은 시계를 사용해야 한다. 기본적으로 NTP를 이용한 해결 방법이 가장 보편적인 수단이다.
- 각 section의 길이 최적화를 통해 커스터마이징하면 효과적으로 사용할 수 있다.
- 필수 불가결한 컴포넌트로 높은 가용성을 제공해야한다.


---
---

추가적으로 고려해보면 좋은 방법들이 있어 소개드립니다.

## Baidu UID Generator
<img width="880" height="128" alt="image" src="https://github.com/user-attachments/assets/067f34e8-c37b-4b94-b7ad-b8990f158945" />

Baidu에서 사용하는 Java로 구현된 Snowflake기반 고유 ID 생성기

|구분|비트수|내용|
|------|---|---|
|Sign  비트|1|항상 0 고정되어 있다.|
|Delta Seconds|28|custom(2016-05-20)한 시간 이후의 시간을 의미한다. 최대 8.7년 |
|Worker ID|22|서버 ID를 나타내며 최대 420만을 의미한다. 재부팅시 기본적으로 이전 워커 노드의 id는 폐기한다.|
|Sequence |13|1초 동안 생성가능한 ID개수|

### 구현체
#### DefaultUidGenerator
- snowflake와 동일한 알고리즘을 사용하여 생성하는 방법을 의미한다.

#### CachedUidGenerator 

<img width="744" height="512" alt="image" src="https://github.com/user-attachments/assets/5793f8c1-2f91-4e0e-b17a-6e81987322e9" />

- RingBuffer를 통한 캐싱을 이용한 방법
- 더블 RingBuffer를 사용함(UID, 상태용)

### 장점
- RingBuffer사용시 단일 인스턴스에서 600만 이상의 QPS를 보인다.
- 분산 환경에서 안정적으로 동작하며, snowflake에 비해 많은 워커를 사용할 수 있다.
- 비트 구성이 커스터마이징 가능하다.

### 단점
- snowflake와 동일하게 시계 동기화 필요
- RingBuffer 사용시 메모리 사용량이 높음
---

## MongoDB의 ObjectId
MongoDB에서 document에 사용하는 ObjectId를 의미한다.
예시 : ObjectID("6518aafbb6234c91b2e8a3f7")
|구분|비트수|내용|
|------|---|---|
|Timestamp|32|epoch timestamp를 의미한다.|
|Machine ID|40|machine별 unique id를 의미한다.|
|Process ID|16|process별 유니크한 식별자를 의미한다.|
|Counter |24|1씩 증가시키는 카운터 값을 의미한다.|

### 장점
- ObjectID는 UUID보다 작아서(16바이트) 인덱스 크기와 스토리지 오버헤드가 적다.
- 타임스탬프 기반 정렬로 인해 정렬 및 인덱싱이 더 빠르다.
- 중앙 집중식 권한이 필요하지 않다 (티켓 서버 기반 ID 생성과 달리).
- 각 MongoDB 인스턴스가 독립적으로 고유한 ObjectID를 생성할 수 있다.
- 타임스탬프로 인해 ID가 삽입 순서대로 정렬되어 범위 쿼리와 인덱스 locality가 향상된다.
### 단점
- ObjectID는 같은 초 내에서는 대략적으로 정렬되지만 완전히 정렬되지는 않는다.
- 여러 노드가 동시에 ID를 생성하면 정렬 순서가 완벽하게 보존되지 않을 수 있다.
- 처음 4바이트에 타임스탬프가 저장되므로 문서의 생성 시간을 추출할 수 있어, 일부 사용 사례에서 메타데이터가 노출될 수 있다.
- 4바이트 타임스탬프는 2038년 이후에 문제가 발생할 수 있다.

---

참고
- https://medium.com/@kedarkanase12/unique-id-generator-in-distributed-systems-3b36d9f6d990
- https://github.com/baidu/uid-generator

