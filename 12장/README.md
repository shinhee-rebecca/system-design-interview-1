# 채팅 시스템 설계

## 1단계 문제 이해 및 설계 범위 확정
### 기능
1. 1:1 채팅 및 그룹 채팅 모두 지원
2. 모비일, 웹 모두 지원
3. 단일 계정으로 여러 단말로 동시 접속 지원
4. 푸시 알림
5. 사용자 접속 상태 표시를 지원

## 비기능
1. 텍스트만 주고 받을 수 있음 (메시지 길이는 최대 100,000)
2. 종단간 암호화는 일단 지원하지 않음
3. 채팅 기록은 영원히 보관
4. DAU 5000만, 동시 접속자 백만명
5. 그룹 채팅 최대 100명

### 이든 설계;;
<img width="1302" height="741" alt="image" src="https://github.com/user-attachments/assets/de22beec-f6f5-4319-b701-03dc3300c51a" />

#### 채팅
1. 단말과 웹은 채팅 서버와 웹 소켓 연결을 맺음
2. 무중단 배포를 위해 단말과 채팅 서버에 프록시를 그리고 채팅 서버 사이에 Message Queue를 둠
    - 단말은 배포 전 블루 그룹과 웹 소켓 커넥션을 맺고있고, 배포를 위해 그린 그룹도 배포되어 있는 상태
    - 블루 그룹은 단말과의 웹 소켓 연결을 close 하고, 스트리밍 응답 또는 메시지를 Broker에 Produce
    - 단말은 웹 소켓 라우터를 통해 그린 그룹과 웹 소켓 연결을 맺음
    - 그린 그룹은 Broker로부터 메시지를 Consume 하여 단말에 전달
3. 커넥션을 길게 맺는다는 점에서 웹 소켓을 선호하지는 않지만, 유저 채팅(1:1, 그룹)에 있어서는 여러 이점이 있을 것 같아 웹 소켓 선정
    - ex. 현재 입력중인 유저 표시 등
    - 방 타입에 따라 연결 방식을 다르게 가져갈 수도 있을 듯 (푸시만 받는 방의 경우는 웹 소켓 연결은 필요없음)
4. 알림 서버는 별도 도메인이라고 판단되어 분리하였음.
    - 웹은 별도 제 3자 서비스를 거치지 않고 알림을 받도록 했음.
5. 접속 상태는 주기적으로 본인의 상태를 알리고, 타인의 상태를 읽어온다.

## 2단계 개략적 설계안 제시 및 동의 구하기
서버가 연결을 만드는 것처럼 보이는 기법들에는 폴링, 롱폴링, 웹 소켓 등이 있다.
### 폴링
클라이언트가 주기적으로 서버에게 새 메시지가 있냐고 물어보는 방법으로,
답해줄 메시지가 없는 경우에는 서버 자원이 불필요하게 낭비된다.

<img width="500" height="500" alt="image" src="https://github.com/user-attachments/assets/a0e3fd5a-aad4-4304-84d3-c4763d354dee" />

가상면접사례로 배우는 대규모 시스템 설계 기초 201p

### 롱폴링
폴링을 비효율성을 개선한 기법이 롱폴링.
<img width="500" height="500" alt="image" src="https://github.com/user-attachments/assets/eace541d-0647-4d56-b865-7653e13dbefd" />

가상면접사례로 배우는 대규모 시스템 설계 기초 202p

클라이언트는 새 메시지가 반환되거나 타임아웃 될 때까지 연결을 유지한다.
클라이언트는 새 메세지를 받으면 기존 연결을 종료하고, 서버에 새로운 요청을 보내어 모든 절차를 다시 시작한다.
메시지를 받지 않는 클라이언트도 주기적으로 다시 서버에 접속해야하므로 여전히 비효율적임. 

### 웹 소켓
서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술
처음에는 HTTP 연결이지만, 특정 핸드셰이크 절차를 거쳐 웹 소켓 연결로 업그레이드되며, 한 번 맺어진 연결은 양방향이다.
<img width="500" height="500" alt="image" src="https://github.com/user-attachments/assets/f187ddcf-b3a1-4484-be49-58e3ddd5b49d" />

가상면접사례로 배우는 대규모 시스템 설계 기초 203p
## 개략적 설계안
채팅 시스템은 **무상태 서비스**, **상태 유지 서비스**, **제 3자 서비스 연동**로 나눌 수 있다.
<img width="500" height="500" alt="image" src="https://github.com/user-attachments/assets/8a03c858-a815-49cb-a397-07249c0412c9" />

가상면접사례로 배우는 대규모 시스템 설계 기초 205p

### 무상태 서비스
로그인, 회원가입, 사용자 프로파일 표시 등을 처리한다.
서비스 탐색(Service Discovery)는 클라이언트가 접속할 채팅 서버의 DNS 호스트명을 클라이언트에게 알려주는 역할

### 상태 유지 서비스
상태 유지가 필요한 서비스는 채팅 서비스로, 
서비스 탐색 서비스는 채팅 서비스와 협력하여 특정 서버에 부하가 몰리지 않도록 한다.

### 제 3자 서비스 연동
푸시 알림!

### 규모 확장성
동시접속자 수는 백만명으로 가정, 접속당 10K의 서버 메모리가 필요하다면 약 10GB의 메모리가 필요.

<img width="500" height="500" alt="image" src="https://github.com/user-attachments/assets/09f44845-37f6-4ccd-aad3-4da998d93f7b" />

가상면접사례로 배우는 대규모 시스템 설계 기초 207p

1. 채팅 서버는 클라이언트 사이에 메시지를 중계하는 역할
2. 접속상태 서버는 사용자의 접속 여부를 관리
3. API 서버는 로그인, 회원가입, 프로파일 변경 등 그 외 나머지 전부를 처리
4. 알림 서버는 푸시 알림을 보냄
5. 키-값 저장소는 채팅 이력을 보관

### 저장소
#### 관계형 데이터베이스 vs NoSQL
이 질문에 대답하기 위해서는 데이터의 유형과 읽기/쓰기 연산의 패턴을 고려해야한다.
1. 사용자 프로파일, 설정, 친구 목록처럼 일반적인 데이터는 안정성을 보장하는 관계형 데이터베이스에 보관한다.
2. 채팅 이력 데이터
    - 채팅 이력 데이터의 양은 엄청나다. (페이스북, 왓츠앱은 매일 600억 개의 메시지를 처리한다.)
    - 사용자는 오래된 메시지는 잘 들여다보지 않는다.
    - 검색 등을 통한 무작위 데이터 접근도 지원해야한다.
    - 1:1 채팅 앱의 경우 읽기:쓰기 비율은 약 1:1이다.
3. 키 값 저장소
    - 수평적 규모확장(horizontal scaling)이 쉽다.
    - 데이터 접근 지연시간(latency)가 낮다.
    - 롱 테일(long tail)에 해당하는 부분을 잘 처리하지 못하는 경향이 있다. 인덱스가 커지면 데이터에 대한 무작위 접근을 처리하는 비용이 늘어난다.
    - 페이스북은 **HBase**를 사용하고, 디스코드는 **카산드라**를 사용한다.
  
### 데이터 모델
#### 1:1 채팅 데이터
<img width="300" height="300" alt="image" src="https://github.com/user-attachments/assets/66d07d1a-9224-42f2-9f50-a51e9597c3aa" />

가상면접사례로 배우는 대규모 시스템 설계 기초 209p

기본 키(primary key)는 message_id이며, 정렬 가능하다.

#### 그룹 채팅
<img width="300" height="300" alt="image" src="https://github.com/user-attachments/assets/6b8c32eb-d980-46d1-8f4c-b5df48e05b2a" />

가상면접사례로 배우는 대규모 시스템 설계 기초 209p

(channel_id, message_id)의 복합키를 기본 키로 사용하며, 
그룹 채팅에 적용될 모든 질의는 특정 채널을 대상으로 할 것이기 때문에 channel_id를 파티션 키(partition key)로 사용한다.

#### 메시지 ID
message_id는 메시지들의 순서도 표현할 수 있어야 한다.
id는 고유해야하며, 정렬 가능해야하고, 시간 순서와 일치해야한다.

1. auto_increment: NoSQL은 보통 제공하지 않는다.
2. 스노우 플레이크: 7장 참조
3. 지역적 순서 번호 생성기: 같은 그룹 안에서만 유일성을 보장

## 상세 설계
### 서비스 탐색
서비스 탐색(Service Discovery, ex. Apache Zookeeper)의 주된 역할은 클라이언트에게 채팅 서버를 추천하는 것으로,
클라이언트의 위치, 서버의 용량 등을 기준으로 한다.

### 메시지 흐름
<img width="500" height="500" alt="image" src="https://github.com/user-attachments/assets/22c3e2ef-8557-4727-8bd3-f55bba0e0483" />

가상면접사례로 배우는 대규모 시스템 설계 기초 212p

1. 사용자 A가 채팅 서버 1로 메시지 전송
2. 채팅 서버 1은 ID 생성기를 사용해 해당 메시지의 ID 결정
3. 채팅 서버 1은 해당 메시지를 메시지 동기화 큐로 전송
4. 메시지가 키-값 저장소에 보관됨
5. (a) 사용자 B가 접속 중인 경우 메시지는 사용자 B가 접속중인 채팅 서버로 전송됨
   (b) 사용자 B가 접속 중이 아니라면 푸시 알림 메시지를 푸시 알림 서버로 보냄
6. 채팅 서버 2는 사용자 B에게 웹소켓으로 메시지를 전송.

### 여러 단말 사이의 메시지 동기화
단말마다 가장 최신 메시지의 id(ex. cur_max_message_id)를 관리한다. 
cur_max_message_id 값보다 id 값이 크면 새 메시지로 간주하며, 이 값을 기반으로 동기화할 수 있다.

### 소규모 그룹 채팅에서의 메시지 흐름
<img width="500" height="500" alt="image" src="https://github.com/user-attachments/assets/28fa1249-d139-4850-845e-a05978a9cd7b" />

가상면접사례로 배우는 대규모 시스템 설계 기초 214p

그룹방에 사용자 A, B, C가 있고, 사용자 A가 메시지를 보냈다고 가정했을 때,
메시지가 사용자 B와 사용자 B의 큐에 복사되므로, 그룹의 크기가 클 때는 문제가 될 수 있다.
위챗은 이런 접근법을 사용하고 있으며, 그룹의 크기는 500명으로 제한하고 있다.
-> 대규모의 채팅의 경우 어떻게 해야할까?

### 접속상태 표시
<img width="500" height="500" alt="image" src="https://github.com/user-attachments/assets/aa856e4a-025d-455d-aa34-bd5912d7f85e" />

가상면접사례로 배우는 대규모 시스템 설계 기초 216p

웹 소켓 연결이 맺어지면 접속 상태 서버는 last_active_at 타임스탬프 값을 키-값 저장소에 보관.
로그아웃하면, 사용자의 상태를 online -> offline으로 변경

#### 접속 장애
웹 소켓 접속 장애에 대한 간단한 방법은 연결이 복구될 때까지 오프라인으로 표시하는 것
다만, 짧은시간 동안 연결이 끊어졌다 복귀될 수 있으므로, heartbeat 검사를 통해 이 문제를 해결

클라이언트가 주기적으로 박동 이벤트를 보내고, 마지막 이벤트를 받은 지 n초 이내에 박동 이벤트가 오지 않으면 오프라인으로 바꾸는 방식으로 해결 가능.

### 상태 정보의 전송
<img width="500" height="500" alt="image" src="https://github.com/user-attachments/assets/52956dba-7aba-4792-96aa-185c24a18a2a" />

가상면접사례로 배우는 대규모 시스템 설계 기초 219p

상태 정보 서버는 발행-구독 모델(publish-subscribe model)을 사용한다.
즉, 각각의 친구 관계마다 채널을 하나씩 두는 것. 
가령 사용자 A의 접속 상태가 변경되었다고 하면 그 사실을 A-B, A-C, A-D 채널에 쓰는 것이다.

이 방안은 그룹 크기가 작을 때는 효과적이지만, 그룹의 크기가 커지면 비효율적이므로, 
사용자가 그룹 채팅에 입장하는 순간에만 상태 정보를 읽어가게 하거나, 수동 갱신을 유도하는 방안이 있다.

## 논의해보면 좋을 내용
1. 사진이나 비디오 등의 미디어를 지원하도록 하는 방법:
    -  미디어 파일은 텍스트에 비해 크기가 크다. 압축 방식, 클라우드 저장소, 썸네일 생성등을 논의
2. 종단간 암호화: 메시지 발신인과 수신자 이외에는 아무도 메시지 내용을 볼 수 없다는 뜻
3. 캐시: 클라이언트에 이미 읽은 메시지를 캐시해두면 서버와 주고받는 데이터 양을 줄일 수 있다.
4. 로딩 속도: 데이터, 채널 등을 지역적으로 분산하는 네트워크를 구축하여 앱 로딩 속도를 개선
5. 오류 처리:
    - 채팅 서버 오류: 서버 하나가 죽으면 새로운 서버를 배벙하고 다시 접속할 수 있도록 해야한다.
    - 메시지 재전송: 메시지의 안정적 전송을 보장
