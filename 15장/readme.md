# 문제 이해 및 설계 범위 확정

## 요구사항

- 중요 기능
    - 파일 업로드/다운로드, 파일 동기화, 알림
        - 파일 업로드 & 다운로드 : 업로드 API는 파일을 분할해서 업로드 할 수 있도록 지원한다. API 응답으로는 진행 성공률을 반환해서, 중간에 끊기거나 실패해도 재실행 할 수 있게 한다. 아니면 단순 HTTP 요청이 아니라 웹소켓을 이용해서 업로드 및 다운로드를 지원해야 할 수도 있겠다.
        - 파일 동기화 : 서버는 데이터 동기화 관련된 리비전을 두고, 새로운 데이터가 올라오면 리비전을 올린다. 클라이언트는 폴링 API를 두어 리비전이 변경되었는지 주기적으로 체크한다. 리비전이 변경되었다면 파일 목록을 동기화하는 API를 실행한다. 명시적 다운로드를 하기 전 까지는 파일을 다운로드 하지 않는다.
        - 알림 : 디바이스 목록을 저장하는 서버를 두고, 파일이 업로드 되면 유저의 디바이스들에 알림을 발송한다. (알림센터 설계 방식과 동일)
    - 모바일/웹 동시 지원
        - 모바일/웹 클라이언트를 둘다 개발한다.
        - 위 알림 및 동기화 기능을 위해, 디바이스 정보 뿐만이 아니라 접속 중인 웹 세션에 대한 정보도 서버에서 들고 있어야 한다.
    - 파일 암호화 지원
        - 데이터 손실의 위험성을 최소화 하기 위해 파일 암호화 알고리즘(모르지만 있을 것 같음)을 적용하여 저장한다.
    - 파일 크기는 10GB로 제한
        - 단일 업로드가 아니라 분할 업로드할 수 있도록 API를 설계해야 한다.
    - 천만 DAU 기준으로 설계
        - API를 지원하는 서버 자체의 규모도 커야하지만, 데이터 저장소의 규모를 크게 잡고 확장이 용이하게 해야 한다.
    
    # 개략적 설계안
    
    ## 서버 1대 버전
    
    - 웹서버 : 파일 업로드 & 다운로드 처리
        - 파일 업로드 API
            - 단순 업로드 : 파일 크기가 작을 때
            - 분할 업로드 : 파일 크기가 크고 업로드 중단 가능성이 높을 때
        - 파일 다운로드 API
            - 분할 업로드가 필요한 파일이라면 다운로드도 분할로 지원하는 게 …
            - HTTP 표준 기능의 [Range](https://developer.mozilla.org/ko/docs/Web/HTTP/Guides/Range_requests)를 사용하면, byte 구간을 명시할 수 있어 분할 다운로드 구현이 용이하다.
        - 파일 갱신 히스토리 API
    - 메타데이터 서버 : 사용자 데이터, 로그인 정보, 파일 정보 등 보관
    - 저장소 시스템 : 파일 저장을 위해 1TB 공간 사용

## 서버 여러대 버전

- 단일 서버의 경우 파일 시스템 용량이 다 차면 확장이 어렵다. → 샤딩 적용하여 나누어 저장한다.
- 데이터 저장소로 아마존 S3를 사용한다.
    - 고가용성이 높다는 이점이 있지만, 비용 부담이 어마어마하다.
    - 소규모 서버의 경우 S3로 시작해서 대규모 글로벌 서비스가 잘 되면 자체 스토리지로 이전하는 게 좋다.
- 이외의 확장할 때 고려할 점은 앞에서 다뤘던 이슈들과 동일하다.
    - 로드밸런서 투입해서 트래픽을 분산하고, 장애 시 탐지할 수 있게 한다.
    - 웹 서버, 메타데이터 데이터베이스, 파일저장소 또한 다중화 한다.

## 동기화 충돌 문제

- 공유 저장소를 사용하거나, 여러 디바이스를 지원할 경우 동기화 충돌 문제가 발생할 수 있다.
- 먼저 처리되는 변경은 성공한 것으로 하고, 이후 처리되는 변경은 충돌이 발생한 것으로 표시한다.
    - 서버가 여러 대일 경우 서버간 동기화도 힘들 수 있다. 이 때는 분산락으로 관리하거나 원자적 처리가 필요할 수 있다.

## 설계안 분석

<img width="1440" height="1352" alt="image" src="https://github.com/user-attachments/assets/85c12cbf-6d3e-44fc-91c9-ed0ae7c5fcb5" />

- 블록 저장소 서버
    - 파일 블록을 저장소에 업로드하는 서버
    - 파일을 여러 개의 블록으로 나누어 저장하고, 각 블록에는 고유한 해시값이 할당. 해시값은 메타데이터 베이스에 저장. 파일을 재구성하기 위해서는 블록들을 원래 순서대로 합쳐야 한다.
- 아카이빙 저장소(cold storage)
    - 오랫동안 접근하지 않은 데이터를 위한 저장소
- 알림 서비스
    - 특정 이벤트가 발생했음을 클라이언트에게 알리기 위해 쓰는 발생/구독 프로토콜 기반 시스템
- 오프라인 사용자 백업 큐
    - 클라이언트가 접속중이 아니어서 최신 상태를 확인할 수 없다면 정보를 큐에 두어 나중에 동기화 하게 한다.

# 상세 설계

## 블록 저장소 서버

- 큰 파일들이 정기적으로 갱신되면 전체 파일의 변경을 요청하는 게 많은 네트워크 대역폭을 사용한다.
- 해결사항은 두 가지가 있다.
    - 델타 동기화
        - 파일이 수정되면 전체 파일 대신 수정이 일어난 부분만 동기화한다.
    - 압축
        - 블록 단위로 압축하여 데이터 크기를 줄인다. 압축 알고리즘은 파일 유형에 따라 다르다.
- 블록 저장소 서버는 아래와 같은 일을 한다.
    - 클라이언트가 보낸 파일을 블록으로 분할한다.
    - 각 블록에 압축 알고리즘을 적용한다.
    - 블록에 암호화를 한다
    - 수정된 블록만 저장소 시스템으로 보낸다.

## 높은 일관성 요구사항

- 같은 파일은 단말이나 사용자마다 동일하게 표시되어야 하기 때문에, 강한 일관성을 지원한다.
- 최종 일관성을 지원하는 메모리 캐시에서 강한 일관성을 달성하려면 캐시 Write-through 전략을 적용한다.
- 관계형 데이터베이스를 채택하여 높은 일관성 요구사항에 대응한다.

## 업로드 절차

<img width="1440" height="955" alt="image" src="https://github.com/user-attachments/assets/f51771c2-8637-45be-80ca-0da542b8ef34" />


## 다운로드 절차

<img width="1440" height="950" alt="image" src="https://github.com/user-attachments/assets/726af577-a741-4396-9060-aa7d345599aa" />


## 알림 서비스

- 일관성 유지를 위해 클라이언트는 파일의 수정을 감지하면 다른 클라이언트에 그 사실을 알려야 한다.
- 이벤트 데이터를 클라이언트 단말들로 보내기 위한 전략은 두 가지가 있다.
    - 롱 폴링
        - 알림 서비스와 양방향 통신이 필요하진 않아서 이 방식을 채택한다.
        - 알림 서버와 롱 폴링용 연결을 유지하다가, 특정 파일에 대한 변경을 감지하면 해당 연결을 끊고 최신 내역을 다운로드 한다.
        - 다운로드가 완료되었거나 타임아웃에 도달하면 새 요청을 보내 롱 폴링을 복원해야 한다.
    - 웹소켓
        - 실시간 양방향 통신이 요구되는 채팅 서비스에 적합하다.

<details>
<summary>롱 폴링도 결국 커넥션을 오래 유지해야 하는데, 그냥 폴링을 쓰면 안 되나?(궁금)</summary>

  ## 🔹 1. 실시간성 (Real-time Sync)
  
  - **폴링(polling)** 은 클라이언트가 주기적으로 `“변경 사항 있니?”` 하고 물어보는 방식.
      - 예: 10초마다 API 호출 → 평균 5초 지연 발생.
      - 주기가 짧으면 서버 부하 ↑, 주기가 길면 사용자 경험 ↓.
  - **롱폴링(long polling)** 은 클라이언트가 요청을 열어두고 서버가 변화가 생기면 응답을 돌려줌.
      - 데이터가 바뀌지 않으면 연결을 유지하다가 타임아웃 직전에 새 요청으로 갱신.
      - **즉시 알림** 수준의 실시간성을 제공하면서도 요청 횟수를 최소화.
  
  ---
  
  ## 🔹 2. 서버 리소스 효율
  
  - 단순 폴링은 **불필요한 요청**이 대부분. (변경 없음 → 304 or empty 응답)
  - 드라이브 같은 시스템은 유저 수가 수억 단위라서, 이런 “빈 요청”만으로도 서버에 엄청난 부하 발생.
  - 롱폴링은 **실제 이벤트 발생 시에만 응답**을 주기 때문에 네트워크, DB, 캐시 리소스 절약.
  
  ---
  
  ## 🔹 3. 대체 기술과 비교
  
  - **WebSocket**: 양방향 연결 유지, 더 강력한 실시간성.
      - 하지만 커넥션 유지 비용, 방화벽/프록시 이슈, 복잡성이 있어서 모든 경우에 적합하지 않음.
      - 구글 Drive API도 롱폴링(Webhooks + channels API)을 권장.
  - **서버 푸시(Server-Sent Events, HTTP/2 Push)**: 실시간 알림에 좋지만 브라우저 호환성, 인프라 제약이 있음.
  - **롱폴링**은 상대적으로 단순하면서도 폴링 대비 리소스 효율과 실시간성을 잘 잡은 절충안.
  - 알림 서버와 롱 폴링용 연결을 유지하다가, 특정 파일에 대한 변경을 감지하면 해당 연결을 끊고 최신 내역을 다운로드 한다.
  - 다운로드가 완료되었거나 타임아웃에 도달하면 새 요청을 보내 롱 폴링을 복원해야 한다.
    - 웹소켓
        - 실시간 양방향 통신이 요구되는 채팅 서비스에 적합하다.
</details>

## 저장소 공간 절약

- 중복 제거
    - 중복된 파일 블록을 계정 차원에서 해시 값을 비교하여 제거한다.
- 백업 전략을 구분한다.
    - 한도 설정: 보관해야 하는 파일 버전 개수에 상한을 두고, 가장 오래된 버전은 버린다.
    - 중요한 버전만 보관한다.
- 자주 쓰이지 않는 데이터는 cold storage로 옮긴다.

## 장애 처리

- 블록 저장소 서버 장애 : 블록 저장소 서버에 장애가 발생하면 다른 서버가 미완료 상태이거나 대기 상태인 작업을 이어받아야 한다.
- 클라우드 저장소 장애 : s3 버킷은 다중화 가능하므로, 한 지역에서 장애가 발생하면 다른 지역에서 파일을 가져온다.
- 알림서비스 장애
    - 접속중인 모든 사용자는 알림 서버와 롱 폴링을 유지하기 때문에, 알림 서비스는 많은 사용자와 연결을 유지하고 관리해야 한다.
    - 한 대 서버에서 백만개 이상 접속을 유지하는 것은 가능하지만, 동시에 시작하는 것은 불가능할 수 있다.
- 오프라인 사용자 백업 큐 장애 : 큐도 다중화 해야 한다. 하지만 아주 오랫동안 깨어나지 않는 사용자들까지 큐에 넣어두어야 하나?
- 그 외 장애들은 생략한다.

<img width="736" height="589" alt="image" src="https://github.com/user-attachments/assets/c3671b1e-e7f3-4ff4-9f1a-17a36e100fa6" />
