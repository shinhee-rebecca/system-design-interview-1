# 13장 검색어 자동완성 시스템

### 문제 이해 및 설계 범위 확정

- 사용자가 입력하는 단어는 자동완성될 검색어의 첫 부분으로 한정
- 질의 빈도에 따라 정해지는 검색어 인기순위를 기준으로 삼음
- 영어 소문자만 지원
- DAU 1000만명 기준

### 요구사항

- 빠른 응답 속도
- 연관성 : 자동완성되어 출력되는 검색어는 사용자가 입력한 단어와 연관된 것이어야 함
- 정렬 : 인기도 등에 의해 정렬되어 있어야 함
- 규모 확장성 및 고가용성

### 개략적 규모 추정

- 한 사용자는 매일 10건의 검색을 수행
- 질의시마다 평균적으로 20바이트의 검색어를 입력
    - 4개의 단어, 각 단어는 5글자, 1글자는 1바이트
- 질의 가운데 20%는 신규 검색어로 가정

## 질의 서비스

### 설계안 1 : 빈도테이블

query : 질의문을 저장하는 필드  
frequency : 질의문이 사용된 빈도를 저장하는 필드

- 위 두 column으로 구성된 테이블에 매 타이핑마다 query를 날리는 방식
- 데이터 양이 적을 때는 가능하지만 많으면 DB가 병목이 될 수 있음

### 설계안 2 : 트라이 자료구조

p : 접두어의 길이  
n : 트라이 안에 있는 노드 개수  
c : 주어진 노드의 자식 노드 개수  

시간 복잡도 : O(p) + O(n) + O(clogc)  
(접두어를 표현하는 노드를 찾기 + 해당 노드부터 하위 트리를 탐색하여 모든 유료 노드 찾기 + 유효 노드를 정렬하여 가장 인기 있는 검색어 k개 찾기)

### 설계안 3 : 트라이 자료구조 개선

검색어의 최대 길이를 제한 : O(p) -> O(1)
노드에 인기 검색어 캐시 : O(n) + O(clogc) -> O(1)
- 저장공간과 속도 사이의 트레이드 오프

## 데이터 수집 서비스

### 설계안 1 : 매번 갱신

질의가 입력될 때마다 트라이를 갱신하기
- 질의 서비스는 심각하게 느려질 것
- 인기 검색어는 자주 바뀌지 않으므로 자주 갱신할 필요가 없음

### 설계안 2 : 일정 주기로 갱신

1. 데이터 분석 서비스 로그에 원본 데이터를 쌓고 취합한다.
2. 작업 서버에서 주기적으로 비동기 작업을 통해 트라이 자료구조를 만들고 DB에 저장한다.
- document store이나 키-값 저장소에 저장한다.

## 전체 설계

(웹 브라우저, 모바일 앱)  
|  
(로드 밸런서)  
|  
(API 서버)  
|  
(트라이 캐시)  
|  
(트라이 데이터베이스)  

### 질의 서비스 속도 높이기

1. AJAX 요청  
: 브라우저 전체를 새로고침하지 않고 서버와 데이터 베이스를 주고 받는다.

2. 브라우저 캐싱  
: 구글의 경우 3600초, 즉 1시간 동안 검색어들을 캐시해둔다고 한다.

3. 데이터 샘플링  
: 모든 질의 결과를 로깅하지 않고 일부 결과만 로깅해둔다.

### 검색어 삭제

트라이 캐시 앞에 필터 계층을 두고 부적절한 질의어가 반환되지 않도록할 수 있다.  
이 경우 DB에서 해당 검색어를 물리적으로 삭제라는 것은 다음 업데이트 사이클에 비동기적으로 수행한다.

### 저장소 규모 확장하기

글자 기준 샤딩 : 데이터를 각 서버에 균등하게 배분하기 어려움  
해결책 : 과거 질의 데이터 패턴을 분석하여 샤딩

### 추가 질문

비영어권 국가 지원 : 유니코드  
국가별 인기 검색어 순위 : 국가별 다른 트라이  

